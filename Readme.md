# 设计模式

## 创建型

### 单例
1. 私有化构造器
2. 暴露一个获取实例方法
3. 考虑是否支持懒加载，是否线程安全
* 饿汉
  * 非懒加载，线程安全有JVM实现
* 懒汉
  * 懒加载，线程不安全
* 双重检查锁
  * 懒加载，线程安全
* 静态内部类
  * 懒加载，类的静态常量因而线程安全
* 枚举
  * 天然单例，本质静态常量
#### 存在的问题
* 反射入侵
  * 构造器里加个判空
* 序列化与反序列化
  * readResolve()方法

### 工厂
* 简单工厂
  * 单个工厂，根据条件，生产对应产品
* 抽象工厂
  * 工厂被抽象，需要生产商品时，实现对应的工厂
* 工厂方法
  * 产品也抽象，工厂也抽象，且单个工厂可以生产产品族
  * 生产产品分别去实现具体产品和具体工厂

### 建造者
* 标准流程
  * 产品+抽象建造者+具体建造者+指挥者
* 内部类
  * 抽象建造者移除，具体建造者成为静态内部类，持有外部的产品类，同时能够设置其属性
* 不可变对象（基于内部类Builder）
  * 私有化构造函数，让外界无法直接通过ImmutablePerson类来构建，构造器传入的为Builder。
  * 通过 Builder 类的方法来设置属性值，可以选择性地设置需要的属性，而不需要在构造函数中传递一堆参数。这样可以更灵活地构建对象，并且只设置感兴趣的属性。 
  * 如果在构建 ImmutablePerson 对象时不一次性给外部类的属性赋值，可能会导致 ImmutablePerson 对象处于不完整或不一致的状态。【对象处于无效状态】

### 原型
* 浅拷贝
  * 只拷贝一层，可以直接赋值，也可以clone
* 深拷贝
  * 递归克隆：对于非从基础类型，需要额外拷贝再赋值走
  * 序列化：使用对象，对原型对象进行序列化， 再对序列化后的二进制流执行反序列化操作，就可以得到一个完完全全相同的新对象。